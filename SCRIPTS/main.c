/* Main.c file generated by New Project wizard
 *
 * Created:   jue abr 26 2018
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */

#include <xc.h>
#define _XTAL_FREQ 8000000  

#include <string.h>
#include "config.h"
#include "GLCD.h"

#include <stdio.h>

#define SQ_SIZE 4
#define MAX_ROWS 16
#define MAX_COLS 32

#define stylish 1 // only 0 or 1 (0 -> no lines between squares, 1 -> lines between squares better visibility)

char MAPA[MAX_ROWS][MAX_COLS];

char peces[5][4][4][4] = { //Pal
   {
    {{0, 1, 0, 0}, {0, 1, 0, 0}, {0, 1, 0, 0} ,{0, 1, 0, 0}}, //figura 0
    {{0, 0, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0} ,{0, 0, 0, 0}}, //figura 1
    {{0, 0, 1, 0}, {0, 0, 1, 0}, {0, 0, 1, 0} ,{0, 0, 1, 0}}, //figura 2
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {1, 1, 1, 1} ,{0, 0, 0, 0}}  //figura 3
   },
    
    //T
   {
    {{0, 0, 0, 0}, {1, 0, 0, 0}, {1, 1, 0, 0} ,{1, 0, 0, 0}}, //figura 0
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {1, 1, 1, 0} ,{0, 1, 0, 0}}, //figura 1
    {{0, 0, 0, 0}, {0, 1, 0, 0}, {1, 1, 0, 0} ,{0, 1, 0, 0}}, //figura 2
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 1, 0, 0} ,{1, 1, 1, 0}}  //figura 3
   },
   
   //Quadrat
   {
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 1, 1, 0} ,{0, 1, 1, 0}}, //figura 0
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 1, 1, 0} ,{0, 1, 1, 0}}, //figura 1
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 1, 1, 0} ,{0, 1, 1, 0}}, //figura 2
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 1, 1, 0} ,{0, 1, 1, 0}}  //figura 3
   },
   
   //L
   {
    {{0, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0} ,{1, 1, 0, 0}}, //figura 0
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {1, 1, 1, 0} ,{1, 0, 0, 0}}, //figura 1
    {{0, 0, 0, 0}, {1, 1, 0, 0}, {0, 1, 0, 0} ,{0, 1, 0, 0}}, //figura 2
    {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 1, 0} ,{1, 1, 1, 0}}  //figura 3
   },
   
   //z
   {
    {{0, 0, 0, 0}, {0, 1, 1, 0}, {0, 1, 0, 0} ,{1, 1, 0, 0}}, //figura 0
    {{0, 0, 0, 0}, {1, 0, 0, 0}, {1, 1, 1, 0} ,{0, 0, 1, 0}}, //figura 1
    {{0, 0, 0, 0}, {0, 1, 1, 0}, {0, 1, 0, 0} ,{1, 1, 0, 0}}, //figura 2
    {{0, 0, 0, 0}, {1, 0, 0, 0}, {1, 1, 1, 0} ,{0, 0, 1, 0}}  //figura 3
   }
};

// Variables for async comunication
int updateY;
int updateRotation;
int updateAcceleration;

// Variables for time management
int initialTimer;
char shouldMovePiece;

char provisionalInfo;

const char * GameOverMessage = "G A M E  O V E R\n";
const char * RestartingMessage = "R E S T A R T I N G\n";

void interrupt management(void) {
   // si la interrupcio es de timer0 movem la peca
   if (INTCONbits.TMR0IE && INTCONbits.TMR0IF) {
      shouldMovePiece = 1;
      INTCONbits.TMR0IF = 0;
      TMR0 = initialTimer;
   }
   
   // si la interrupcio es perque arriba caracter del teclat
   if(PIE1bits.RC1IE == 1 && PIR1bits.RC1IF == 1) {
      PIE1bits.RC1IE = 0;
      char key_pressed = RCREG1;
      provisionalInfo = key_pressed;
      if(key_pressed == 'w') {
	 updateRotation++;
	 updateRotation%=4;
      } else if (key_pressed == 'a') {
	 updateY--;
      } else if (key_pressed == 's') {
	 updateAcceleration = 1;
      } else if (key_pressed == 'd') {
	 updateY++;
      }
      PIE1bits.RC1IE = 1;
      PIR1bits.RC1IF = 0;
   }
}

void writeText(byte page, byte y, char * s) {
   int i=0;
   while (*s!='\n' && *s!='\0') {
      putchGLCD(page, y+i, *(s++));
      i++;
   }
}

void configPIC() {
   
  //CONFIGUREM EL ADC I ELS BOTONS ESQUERRA, DRETA, ROTACIO i ACCELERACIO

  ANSELA = 0x01;	// potenciometre en analog i botons en digital
  TRISA = 0x1F;		// inputs
  
  ADCON0 = 0x03;
  ADCON1 = 0x80;
  ADCON2 = 0x89;
  
  //CONFIGUREM LA GLCD   
   
  ANSELB = 0;
  ANSELD = 0;
   
  PORTD=0; 		   //Donem uns valors inicials als ports
  PORTB=0;
   
  TRISD=0x00;		   //Configurem D i B de sortida
  TRISB=0x00;		   

  GLCDinit();		   //Inicialitzem la pantalla
  clearGLCD(0,7,0,127);      //Esborrem pantalla
  setStartLine(0);		//Definim linia d'inici
  
  
  // CONFIGUREM COMUNICACIÓ ASÍNCRONA
  ANSELC = 0;
  
  TXSTA1bits.SYNC = 0;
  TXSTA1bits.BRGH = 1;
  BAUDCON1bits.BRG16 = 1;
  SPBRG1 = 16;	// all four, following formula: FOSC/(4*(n-1)) = baud_rate, where n = 16
  SPBRGH1 = 0;
  
  TRISCbits.RC7 = 1;	// input
  TRISCbits.RC6 = 1;	// input (maybe not necessari)
  
  RCSTA1bits.SPEN = 1;	// enable serial port
  
  PIE1bits.RC1IE = 1;	// interrupt enabled
  
  RCSTA1bits.CREN = 1; 	// enable reception
  
  PIR1bits.RC1IF = 0;	// interrupt flag a 0
  
  IPR1bits.RC1IP = 1;	// high priority
  
  PORTC = 0x80;
  
  //TIMER
  
  T0CON = 0x05;		// Configuracion Timer0 (Prescaler 1:64)
  INTCONbits.TMR0IE = 1;
  INTCONbits.TMR0IF = 0;
  TMR0ON = 1;
  
  // HABILITEM INTERRUPCIONS
  
  RCONbits.IPEN = 1;
  INTCONbits.GIEH = 1;
  INTCONbits.GIEL = 1;
}

// torna 1 si la posicio es correcta dins MAPA
char pos_ok(int x, int y) {
   return !(x < 0 || x >= MAX_ROWS || y < 0 || y >= MAX_COLS);
}

// pinta un quadrat SQ_SIZE*SQ_SIZE (p.ex. part d'una peça) a MAPA[x][y]
void paintSq(int x, int y) {
   if (!pos_ok(x,y)) return;
   int xx = x*SQ_SIZE;
   int yy = y*SQ_SIZE;
   for (int i = stylish; i < SQ_SIZE; ++i) {
      for (int j = stylish; j < SQ_SIZE; ++j) {
	 SetDot(xx+i, yy+j);
      }
   }
}

// pinta la peça amb la rotacio adient a MAPA[x][y]
void paintPiece(int peca, int rotacio, int x, int y) {
   for (int i = 0; i < 4; ++i) {
      for (int j = 0; j < 4; ++j) {
	 if(peces[peca][rotacio][i][j]) paintSq(x+i,y+j);
      }
   }
}

// pinta les posicions del MAPA que siguin true
void paintMAPA() {
   for(int i = 0; i < MAX_ROWS; ++i) {
      for (int j = 0; j < MAX_COLS; ++j) {
	 if (pos_ok(i,j) && MAPA[i][j]) paintSq(i,j);
      }
   }
}

// marca els quadrats que ocupa una peça com a true al mapa, si hi ha un quadrat fora del mapa torna 1
char markOnMAPA(int peca, int rotacio, int x, int y) {
   for (int i = 0; i < 4; ++i) {
      for (int j = 0; j < 4; ++j) {
	 if(peces[peca][rotacio][i][j]) {
	    if (pos_ok(x+i, y+j)) MAPA[x+i][y+j] = 1;
	    else return 1;
	 }
      }
   }
   return 0;
}

//Pre: es passa la posicio seguent en les x
// retorna cert si la posicio esta a baix de tot o si colisiona con true en MAPA
char shouldStop(int peca, int rotacio, int x, int y) {
   for (int i = 0; i < 4; ++i) {
      for (int j = 0; j < 4; ++j) {
	 if(peces[peca][rotacio][i][j]) {
	    if(x+i == MAX_ROWS) return 1;
	    if (pos_ok(x+i, y+j) && MAPA[x+i][y+j]) return 1;
	 }
      }
   }
   return 0;
}

// inicialitza el mapa tot a false
void initMAPA() {
   for(int i = 0; i < MAX_ROWS; ++i)
      for (int j = 0; j < MAX_COLS; ++j)
	 MAPA[i][j] = 0;
}

// retorna quants quadrats de la peca a la rotacio a la posicio x,y sobresurten del mapa pels costats
char posOutside(int peca, int rotacio, int x, int y) {
   if (y < 0) {
      for (int i = 0; i < SQ_SIZE; ++i) {
	 for (int j = 0; j < SQ_SIZE && y+j<0; ++j) {
	    if (peces[peca][rotacio][i][j] && !pos_ok(x+i,y+j)) return -y-j; //la peca te quadrats a l'esquerra de la pantalla
	 }
      }
   } else if (y > MAX_COLS-SQ_SIZE) {
      for (int i = 0; i < SQ_SIZE; ++i) {
	 for (int j = SQ_SIZE-1; j >= 0; --j) { // j comença per la dreta per trobar la primera pos el mes enfora possible
	    if (peces[peca][rotacio][i][j] && !pos_ok(x+i,y+j)) return y+j-(MAX_COLS-1); //la peca te quadraats a la dreta de la pantalla
	 }
      }
   }
   return 0;
}

// retorna la primera rotació correcta des de rotacio+update, o -1 si no n'hi ha
// si la peca esta a l'ultima fila no es podra rotar
int canRotate(int peca, int rotacio, int x, int y, int update) {
   update %= 4;
   if (y < 0) {
      for (int i = update; i > 0; --i) {
	 if (!shouldStop(peca, (rotacio+i)%4, x, y+posOutside(peca, (rotacio+i)%4, x, y))) return (rotacio+i)%4;
      }
   }
   else if (y > MAX_COLS-SQ_SIZE) {
      for (int i = update; i > 0; --i) {
	 if (!shouldStop(peca, (rotacio+i)%4, x, y-posOutside(peca, (rotacio+i)%4, x, y))) return (rotacio+i)%4;
      }
   }
   else {
      for (int i = update; i > 0; --i) {
	 if (!shouldStop(peca, (rotacio+i)%4, x, y)) return (rotacio+i)%4;
      }
   }
   return -1;
}

// retorna la posicio mes lluny a on es pot moure des de y a un maxim de y+update
// si la peca esta a l'ultima fila no es podra moure
int canMove(int peca, int rotacio, int x, int y, int update) {
   int movement = y+update;
   if (movement >= MAX_COLS-SQ_SIZE)
      movement -= posOutside(peca, rotacio, x, movement);
   else if (movement <= 0) 
      movement += posOutside(peca, rotacio, x, movement);
   
   // per mirar si hi ha obstacles entre pos actual i pos destí
   if (movement < y) {
      for (int i = y; i > movement; --i) if (shouldStop(peca, rotacio, x, i-1)) return i;
      return movement;
   } else {
      for (int i = y; i < movement; ++i) if (shouldStop(peca, rotacio, x, i+1)) return i;
      return movement;
   }
}

// clears the rows that are full from map, marks which rows have been cleared from map, and if any returns the number, else 0;
char clearFullRows(char* allRows) {
   char cleared = 0;
   for (int i = 0; i < MAX_ROWS; ++i) {
      char found_a_zero = 0;
      for (int j = 0; j < MAX_COLS && !found_a_zero; ++j) {
	 found_a_zero = !MAPA[i][j];
      }
      if (!found_a_zero) { //we clear that row and mark it on allRows, cleared++
	 for (int j = 0; j < MAX_COLS; ++j) MAPA[i][j] = 0;
	 allRows[i] = 1;
	 cleared++;
      } else allRows[i] = 0;
   }
   return cleared;
}

// for all the rows above row, marks a 1 on MAPA if there was a 1 on top of that position
void fallAboveRow(int row) {
   for (int i = row-1; i >= 0; --i) {
      for (int j = 0; j < MAX_COLS; ++j) { 
	 MAPA[i+1][j] = MAPA[i][j];
	 if (i == 0) MAPA[i][j] = 0; // la fila de més a munt sempre quedarà buida si hi havia alguna cosa
      }
   }
}

void main(void){
   
   configPIC();
   
   // Initialize global variables
   updateY = 0;
   updateRotation = 0;
   updateAcceleration = 0;
   
   initialTimer = 3036;
   shouldMovePiece = 0;
   
   initMAPA();
   
   char clearedRows[MAX_ROWS];
   
   // Initialize input button controls
   char wasLeftPressed = 0;
   char wasRightPressed = 0;
   char wasRotatePressed = 0;
   char wasAccelPressed = 0;
   
   provisionalInfo = '0';

   while(1){
     
      int peca = rand()%5;
      int rotacio = rand()%4;
      
      int x = -3;
      int y = rand()%27;
     
      char pecaAtEnd = 0;
      while(!pecaAtEnd) {
	 // check if any buttons are on rising edge for input
	 char teclat = RCREG1;
	 if (!wasLeftPressed && PORTAbits.RA1) {
	    updateY--;
	    wasLeftPressed = 1;
	 } else if (wasLeftPressed && !PORTAbits.RA1) wasLeftPressed = 0;
	 
	 if (!wasRightPressed && PORTAbits.RA2) {
	    updateY++;
	    wasRightPressed = 1;
	 } else if (wasRightPressed && !PORTAbits.RA2) wasRightPressed = 0;
	 
	 if (!wasRotatePressed && PORTAbits.RA3) {
	    updateRotation++;
	    updateRotation%=4;
	    wasRotatePressed = 1;
	 } else if (wasRotatePressed && !PORTAbits.RA3) wasRotatePressed = 0;
	 
	 if (!wasAccelPressed && PORTAbits.RA4) {
	    updateAcceleration++;
	    wasAccelPressed = 1;
	 } else if (wasAccelPressed && !PORTAbits.RA4) wasAccelPressed = 0;
	 
	 // button actions management
	 if (updateY != 0) {
	    y = canMove(peca, rotacio, x, y, updateY);
	    updateY = 0;
	 }
	 if (updateRotation != 0) {
	    int can = canRotate(peca, rotacio, x, y, updateRotation);
	    if (can != -1) {
	       rotacio = can;
	       if (y < 0) y+=posOutside(peca, rotacio, x, y);
	       else if (y > MAX_COLS-SQ_SIZE) y -= posOutside(peca, rotacio, x, y);
	       updateRotation = 0;
	    }
	 }
	 if (updateAcceleration != 0) {	// cada cop premut el boto accelerar intenta baixar una posicio la peca
	    for (int i = 0; i <= updateAcceleration && !shouldStop(peca, rotacio, x+1, y); ++i) {
	       ++x;
	    }
	    updateAcceleration = 0;
	 }
	 
	 // check for analog input to change timer value at next timer interrupt
	 if (!ADCON0bits.GO) {
	    initialTimer = 3036+(46875*ADRES/1023);
	    ADCON0bits.GO = 1;
	 }
	 
	 // if timer interrupts try to move the piece down
	 if (shouldMovePiece) {
	    updateY = 0;
	    updateRotation = 0;
	    updateAcceleration = 0;
	    shouldMovePiece = 0;
	    
	    if (shouldStop(peca, rotacio, x+1, y)) pecaAtEnd = 1;
	    else ++x;
	 }
	 
	 // repaint board on GLCD
	 clearGLCD(0,7,0,127);
	 paintPiece(peca, rotacio, x, y);
	 paintMAPA();
	 __delay_ms(20);
      }
      
      char gameOver = markOnMAPA(peca, rotacio, x, y);
      char rows;
      if (gameOver > 0) {
	 updateY = 0;
	 updateRotation = 0;
	 updateAcceleration = 0;
	 shouldMovePiece = 0;
	 initMAPA();
	 
	 // game over message
	 clearGLCD(0,7,0,127);
	 writeText(4, 4, GameOverMessage);
	 __delay_ms(3000);
	 
	 // restarting countdown
	 clearGLCD(3,4,0,127);
	 writeText(3, 3, RestartingMessage);
	 
	 for (int i = 3; i > 0; --i) {
	    char countDown[4];
	    sprintf(&countDown, "%d\n", i);
	    writeText(5, 12, countDown);
	    __delay_ms(1000);
	    clearGLCD(4,5,50,77);
	 }
	 
	 clearGLCD(2,5,0,127);
      } else if ((rows = clearFullRows(clearedRows)) > 0) {
	 int idx = MAX_ROWS-1;
	 for (int i = 0; i < rows; ++i) {
	    while(!clearedRows[idx]) idx--;
	    fallAboveRow(idx);
	    clearedRows[0] = 0;
	    for (int j = idx; j > 0; --j)
	       clearedRows[j] = clearedRows[j-1];
	    clearGLCD(0,7,0,127);
	    paintMAPA();
	    __delay_ms(20);
	 }
      }
   }
}